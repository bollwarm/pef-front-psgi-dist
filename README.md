PEF Front
======

# Общий вид

Frontend состоит из нескольких компонент:

* `web\-server` -- принимающий запросы от клиента и обслуживающий статичекские данные, а так же передающий динамические запросы приложению. На данный момент используется комбинация `nginx` + `uwsgi`, но возможна адаптация под любой способ, поддерживающий `PSGI`.
* `PSGI\-демон` -- регулирующий работу PSGI\-приложения. На данный момент это реализуется приложением `uwsgi`, но возможно использование модуля `mod\_psgi` для `Apache2`.
* `PEF Frontend` -- фреймворк, принимающий динамические запросы согласно настройкам приложения
* Приложение, которое пользуется `PEF Frontend`\-ом.

В этом документе будет описано функционирование PEF Frontend и примерная структура предполагаемого приложения.

# Структура приложения

Приложение может сконфигурировать работу фреймворка множеством способов, хотя некоторые предположения о приложении фреймворк всё равно делает. Если приложение следует предположениям, заложенным во фреймворке, то его конфигурация может занимать всего несколько строк. Приложение может описывать локальные обработчики, возвращающие данные, либо пользоваться бекендом типа PEF Core, тогда все запросы о данных будут переадресованы согласно настройкам.

## Файловая структура приложения

```
+ bin/
|- startup.pl
+ conf/
|+ My/
| - myapp.ini
| - nginx-handlers.conf
| - AppFrontConfig.pm
| + InFilter/
| + Local/
| + OutFilter/
+ log/
+ model/
+ templates/
++ var/
|+ cache/
|+ captcha-db/
|+ tt_cache/
|+ upload/
+ www-static/
|+ captchas/
```

## Назначение каталогов

* `bin` -- различные исполняемые файлы, необходимые для функционирования приложеиня.
* `conf` -- конфигурационные параметры и локальные фильтры и обработчики запросов
* `log` -- логи приложения
* `model` -- каталог с описанием доступных вызовов модели
* `templates` -- html-шаблоны
* `var` -- различные файлы, требуемые приложению во время работы
* `www-static` -- статическое содержимое приложения, отдаётся веб-сервером напрямую
* `www-static/captchas` -- сгенерированные капчи
* `var/cache` -- кешируемое сожержимое
* `var/captcha-db` -- база данных по сгенерированнвм изображениям капчи
* `var/tt_cache` -- кеш скомпилированных html-шаблонов
* `var/upload` -- файлы, которые были закачаны в приложение
* `conf/$AppNamespace/InFilter` -- фильтры данных, предаваемых в вызовы запросов к модели
* `conf/$AppNamespace/OutFilter` -- фильтры возвращаемых из запросов данных
* `conf/$AppNamespace/Local` -- локальные обработчики запросов приложения
* `conf/$AppNamespace/AppFrontConfig.pm` -- файл, содержащий конфигурацию приложения

# Конфигурирование приложения

В момент запуска, фреймворк `PEF Front` пытается самостоятельно угадать основные параметры приложения, а затем поверх этих параметров прочитать данные из модуля AppFrontConfig, который должен быть обязательно использован в программе, запускающей приложение, перед использованием запускающего модуля `PEF::Front::Route`.

Конфигурационный модуль `\*::AppFrontConfig` может быть в любом пространстве имён, от его расположения автоматически отсчитываются каталоги InFilter, Local и OutFilter, а так же, пространство имён для соответствующих обработчиков в этих каталогах.

Обычно, запускающий приложение файл `startup.pl` должен выглядеть примерно так:

```
use My::AppFrontConfig;
use PEF::Front::Route ('/' => '/appIndex', qr'/index(.*)' => '/appIndex$1');
PEF::Front::Route->to_app();
```

Основной каталог приложения со структурой, подобной описанной выше, определяется на основе каталога, из которого было запущено приложение.

## Доступные параметры

* app\_namespace -- пространство имён, в котором будут находиться фильтры и локальные обработчики
* cache\_expire -- время хранения данных в кеше по умолчанию, если для ключа хранения не задано своё
* cache\_file -- файл для кеша
* cache\_size -- размер кеша
* captcha\_db -- каталог, где будет находиться база капч
* captcha\_font -- шрифт, используемый при рисовании капчи
* captcha\_secret -- "секретное смещение" для генерируемых кодов md5, по которым сравнивается капча
* db\_name -- имя локальной базы с сообщениями NLS и другой информацией
* db\_password -- пароль локальной базы
* db\_user -- пользователь локальной базы
* db\_reconnect\_trys -- количество попыток реконнекта, если вдруг коннект к базе пропал, между попытками интервал 1 сек.
* default\_lang -- язык приложения по умолчанию
* in\_filter\_dir -- каталог с фильтрами данных, предаваемых в вызовы запросов к модели
* location\_error -- страница с ошибкой, куда приложение может отправить браузер пользователя
* model\_dir -- каталог с описанием вызовов модели
* model\_local\_dir -- каталог с локальными обработчиками
* model\_rpc -- функция, возвращающая объект для связи с бекендом
* model\_rpc_admin\_addr -- адрес бекенда для администрирования
* model\_rpc_admin\_port -- порт бекенда для администрирования
* model\_rpc_site\_addr -- адрес бекенда для клиентского сайта
* model\_rpc_site\_port -- порт бекенда для клиентского сайта
* no\_multilang\_support -- флаг, что приложение не собирается поддерживать многоязыковую конфигурацию
* no\_nls -- флаг, что приложению вообще не требуется трансляция сообщений
* out\_filter\_dir -- каталог с фильтрами возвращаемых из запросов данных
* template\_cache -- кеш скомпилированных html-шаблонов
* template\_dir -- html-шаблоны приложения
* template\_dir\_contains\_lang -- флаг, обозначающий, что шаблоны для разных языков будут лежать в разных каталогах по соответствующему сокращению языка
* upload\_dir -- каталог для закачиваемых файлов в приложение
* url\_contains\_lang -- флаг, обозначающий, что URL в префиксе содержит сокращённоое название языка
* www\_static\_captchas\_dir -- каталог со сгенерированными капчами
* www\_static\_dir -- каталог со статическим содержимым

Для изменения параметров, в модуле \*::AppFrontConfig необходимо определить функцию с соответствующим названием. Например:

```
sub db_user                    {"scott"}
sub db_password                {""}
sub db_name                    {"tiger"}
```

## Конфигурационные данные с параметрами

Некоторые функции принимают значения, но большинство нет. Следующие функции работают с параметрами:

* model\_rpc($model) -- принимает значение параметра `model` из соответствующего файла конфигурации вызова
* template\_dir($hosname, $lang) -- принимает параметром имя сайта и язык, чтобы вернуть соответствующий каталог с шаблонами

# Пример применения

В данном разделе описывается один конкретный из множества вариантов способ применения фреймфорка.

## Компоненты
### nginx

Примерный файл его конфигурации выглядит вот так:

```
server {
	listen 80 default_server;
	root /var/www/www.example.com/www-static;
	index index.html index.htm;
	client_max_body_size 100m;
	server_name www.example.com;
	location =/favicon.ico {}
	location /css/ {}
	location /jss/ {}
	location /fonts/ {}
	location /images/ {}
	location /styles/ {}
	location / {
	    include uwsgi_params;
	    uwsgi_pass 127.0.0.1:3031;
	    uwsgi_modifier1 5;
    }
	location ~ /\. {
		deny all;
	}
}
```

Некоторые пути доступа отдаются `nginx`-ом самостоятельно, не делая запроса в приложение, `nginx` это сделает лучше любого другого варианта.

### uwsgi

Примерный файл конфигурации для демона `uwsgi` выглядит так:

```
[uwsgi]
plugins = psgi
socket = 127.0.0.1:3031
chdir = /var/www/www.example.com
psgi = bin/startup.pl
master = true
processes = 8
stats = 127.0.0.1:5000
perl-no-plack = true
cheaper-algo = spare
cheaper = 2
cheaper-initial = 5
cheaper-step = 1
```

### Фреймворк

Фреймворк устанавливается обычным make install способом.

### Приложение

В случае, если приложение максимально похоже на то, что предполагается фреймворком, то конфигурирование требуется минимальное. Достаточно только наполнить проект "содержанием".

## Запуск

После запуска веб-сервера и uwsgi, приложение становится полностью функциональным.

# Функционирование фреймворка
## Принцип построения приложения

1. Определяются необходимые страницы, их шаблоны и необходимые для них данные.

Для того, чтобы контроллер функционировал автоматически, доступные вызовы API должны быть описаны. Для описания вызовов используется формат YAML, как наиболее "редактируемый".

На каждый вызов API требуется свой файл. Один вызов -- один файл. В этом файле описываются передаваемые параметры, правила их проверки, значения по умолчанию, реакция на ответ, правила кеширования ответа. Имя файла однозначно определяет имя вызываемого метода API, для этого используется простая трансляция "method name" == MethodName.yaml.

Методы можно вызывать напрямую как URL на сайте или для получения данных в шаблоне. В случае вызова по URL, используется такая же трансляция "method name" == /(ajax|submit|get)MethodName. В случае вызова из шаблона, вызов выглядит примерно как [% r = "method name".model({param => "value"}) %] или просто [% r = "method name".model %] если параметры не нужны или могут быть подставлены автоматически.

# AJAX

В случае вызова по URL доступны следующие префиксы:
* ajax -- в этом случае ответ ядра будет передан в виде JSON-текста, обработка результатов не будет учитывать возможные редиректы.
* submit -- в этом случае ответом подразумевается редирект на новый URL или прямой ответ значения, например для ответа платёжным системам.
* get -- так же, как и submit, но может принимать дополнительные параметры как части URL. Предназначено для ссылок в письме или других запросов. Например https://domain.com/getConfirmNewEmail/2134242342423 -- здесь параметр, если не указано его имя, будет называться cookie. Можно передавать несколько параметров, которые разделяются символом '/', имя параметра от значения отделяется символом '-'.

В хеше defaults доступны следующие элементы:

```
{
		ip     => $ip,
		lang   => $lang,
		domain => $hostname,
		url    => $uri,
		form   => $form,
		cookie => $cookie,
		(exists($cookie->{auth})     ? (auth      => $cookie->{auth})     : ()),
		(exists($cookie->{auth_adm}) ? (auth_adm  => $cookie->{auth_adm}) : ()),
}
```

* ip -- IP откуда пришёл запрос.
* lang -- язык из куки lang или угаданный из доступных на сайте, с учётом GeoIP.
* domain -- текущий домен.
* url -- путь запроса в пределах домена
* form -- содержание переданной формы
* cookie -- все переданные куки
* auth -- если браузер предъявил куку авторизации
* auth\_adm -- если браузер предъявил куку авторизации админа

Предполагается, что сайт для админа и сайт для клиента находятся на разных машинах, чтобы было невозможно перехватить куку админа на клиентском сайте. Тем не менее, куки у них, на всякий случай, разные.

Приблизительное содержание для описания вызова модели может выглядеть так:

SendMessage.yaml:
```
---
params:
    ip:
        regex: ^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$
        value: defaults.ip
    auth:
        value: defaults.auth
        max-size: 40
        optional: true
    from:
        regex: ^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})$
        min-size: 7
        optional: true
    lang: ^[a-z]{2}$
    site:
        default: defaults.domain
    subject:
        max-size: 60
        min-size: 5
    message:
        max-size: 600
        min-size: 5
extra_params: ignore # ignore, pass, disallow
model: site
allowed_source:
    - ajax # ajax, submit, template
    - submit

```

При описании regexp-а, проверяющего содержание, возможно использование уже готовых вариантов из Regexp::Common 'RE_ALL'. Эти все проверки читаются из файла один раз, при первом обращении к методу и могут перечитваться автоматически, если файл изменился. По перечню проверок строится функция, их выполняющая, она компилируется и ссылка на неё сохраняется, поэтому проверки работают так же, как если б программист сам руками их написал.

# Формат файла
## Параметры

Ключ params описывает передаваемые в метод параметры. Каждый параметр может иметь атрибуты или просто описывать regexp для проверки допустимости. Атрибуты бывают следующими:
* regex -- задаёт проверочное регулярное выражение.
* captcha -- задаёт проверочное поле формы для капчи
* type -- тип значения. для случаев сложных данных, например, когда передаётся массив или хеш.
* max-size -- максимальный размер для скаляра, массива или количества ключей хеша.
* min-size -- минимальный размер для скаляра, массива или количества ключей хеша.
* can или can_string -- перечень строковых значений, которые может принимать параметр.
* can\_number -- перечень допустимых числовых значений.
* default -- значение по умолчанию. может быть значением из defaults или передано в запросе.
* value -- то же, что и default, но не может быть передано в запросе. взаимоисключающе с default.
* optional -- параметр не обязателен.

## Лишние параметры

Если в запросе передано больше параметров, чем нужно, то есть три варианта поведения:
* ignore -- проигнорировать все лишние параметры, в ядро ничего лишнего не будет передано.
* pass -- пропустить параметры в ядро без проверок.
* disallow -- при наличии лишних параметров проверка будет неуспешна, никакого вызова ядра не будет, будет сообщение об ошибке.
Вариант действия выбирается ключом extra_params.

## Метод вызова
Параметр call_method задаёт метод вызова. Предусмотрено три варианта:
* model -- вызов идёт к серверу модели, обслуживающему клиентский сайт.
* model_admin -- вызов идёт к серверу модели, обслуживающему админский сайт.
* локальный обработчик на фронтенде. Для задействования его необходимо указать два аттрибута class и function.

### Как работает капча

Использования локального обработчика на примере капчи.

Captcha.yaml:
```
---
params:
    width:
        default: 35
    height:
        default: 40
    size:
        default: 5
extra_params: ignore
call_method:
    class: PEF::Captcha
    function: make_captcha
```

SendMessage.yaml:
```
---
params:
    ip:
        value: defaults.ip
    email:
        regex: ^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})$
        min-size: 7
    lang:
        value: defaults.lang
    captcha_code:
        min-size: 5
        captcha: captcha_hash
    captcha_hash:
        min-size: 5
    subject:
        max-size: 60
        min-size: 5
    message:
        max-size: 600
        min-size: 5
result:
    OK:
        redirect: /appLogin
    DEFAULT:
        redirect: /appRegister
call_method: model
allowed_source:
    - submit # ajax, submit, template
    - ajax
```

В шаблоне присутствует примерно следующий код:
```
<form method="post" action="/submitSendMessage">
Captcha:
[% captcha="captcha".model %]
<input type="hidden" name="captcha_hash" value="[% captcha.captcha_code %]">
<img src="[% captcha.captcha_path %]">
<input type="text" maxlength="5" name="captcha_code">
...
</form>
```

Капча формируется на фронтенде и там же она проверяется перед посылкой данных в ядро. Проверка капчи деструктивна, проверить её правильность возможно только один раз, в следующий раз код, который только что был правильным, уже будет использован и его проверка не пройдёт. Вызов "captcha".model формирует картиинку, вносит информацию о ней в базу данных и отдаёт ссылку на неё. Если требуется перезагрузка картинки, то на ajax делается вызов /ajaxCaptcha, информация из которого используется для прописывания нового содержимого поля captcha\_hash. В момент вызова /submitSendMessage будет произведена автоматическая проверка соответствия капчи. Для случая, когда сообщение отправляется зарегистрированным пользователем, можно капчу не требовать, но параметр captcha\_code всё равно необходим. В этом случае предусмотрено специальное значение "nocheck", чтобы фронтенд не проверял капчу для зарегистрированного пользователя, в этом случае проверка переносится в ядро. Ядро должно увидеть, что пришло сообщениие от незарегистрированного пользователя и с непроверенной капчей и среагировать соответственно.

## Описание базовых параметров
Набор необходимых передаваемых параметров можно описать один раз в специальном файле -base-.yaml и затем использовать при описании конкретных вызовов. Например:
-base-.yaml:
```
---
params:
    ip:
        value: defaults.ip
    auth:
        default: defaults.auth
        max-size: 40
        optional: true
    cookie:
        max-size: 40

```
Затем в файле GetClientInfo.yaml:
```
---
params:
    ip: $ip
    auth: $auth
call_method: model
```
Базовый параметр можно указать простой записью значения, начинающегося с '$' и указывающего на запись в -base-.yaml или через аттрибут base. В последнем случае возможно добавить новые аттрибуты или изменить базовые для данного вызова.

## Разрешённые источники вызова
Некоторые вызовы логично допускать только при формировании шаблонов, например, и не разрешать их вызывать по URL. Это контролируется параметром allowed_source. Можно задавать как одно значение, так и массив. Варианты источников:
* ajax -- разрешён тип вызова AJAX.
* submit -- разрешён submit и get.
* template -- разрешён вызов из шаблона.
Если список разрешённых источников не указан, то он не проверяет -- доступен любой.

## Обработка результата ответа
Ключ result определяет действия, который необходимо совершить при получении ответа от ядра. Ядро возвращает, как правило, следующие варианты ответа:
```
{
    result => "OK",
...
}
либо
{
    result => "SOMEERRCODE",
    answer => 'Some $1 Error $2 Message $3',
    answer_args => [$some, $error, $params],
...
}
```
На основании ключа ответа result, выбирается действие из соответственного описания result. Плюс есть специальное описание DEFAULT, которое используется, когда никакое другое не подошло. В аттрибутах действия можно опиисать:
* redirect -- временный редирект браузера для submit и get запросов.
* set-cookie -- установить куку. аттрибутом выступают названия устанавливаемых кук, а все их аттрибуты передаются напрямую в конструктор Apache2::Cookie.
* unset-cookie -- сбросить куку браузера.
* filter -- специальный фильтр, обрабатывающий ответ
* answer -- прямое значение ключа answer в ответе

### Фильтры ответов
По смыслу примерно то же самое, что и локальные обработчики запросов, но несколько специфичные по назначению. Фильтр представляет собой модуль в иерархии PEF::Filter::* у которого есть функция process, которой передаются значения ($response, $defaults), на основании которых она может возвращать новый $response. Смысл в получении каких-либо данных от ядра и выдаче их по новому формату, например XML, CSV, XLS и подобными.

## Кеш ответов ядра
Некоторые данные от ядра могут меняться редко, для этого предусмотрено кеширование. Кешированием управляет ключ cache. У него есть два атрибута:
* key -- значение или массив, описываются параметры, от которых зависит выборка.
* expires -- как долго можно считать значение актуальным. Разбор этого параметра ведётся модулем Time::Duration::Parse.
Пример описания ключа:
```
cache:
    key: method
    expires: 1m
```
