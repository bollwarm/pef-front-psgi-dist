=encoding utf8
 
=head1 NAME
 
PEF::Front - B<P>erl B<E>ffective Web <F>ramework
 
=head1 SYNOPSIS
 
  # startup.pl
  use MyApp::AppFrontConfig;
  use PEF::Front::Preload qw(no_db_connect);
  use PEF::Front::Route ('/' => '/appIndex');
  
  PEF::Front::Route->to_app();
 
  # MyApp::AppFrontConfig.pm
  package MyApp::AppFrontConfig;
  sub cfg_no_nls { 1 }
  sub cfg_no_multilang_support { 1 }
  
  1;
  
  # $project_dir/templates/index.html
  some L<Template::Alloy/"Template::Toolkit style usage"> template.

=head1 DESCRIPTION

PEF::Front is a Perl web framework with following features.

=over

=item B<Easy in development>

You just write API of your application and it's automatically exposed as AJAX
or data retrieving methods in your templates. HTML templates can be programmed
separately.

=item B<Fast and versatile template engine>

HTML templates can be programmed by other people who know nothing about Perl.

=item B<Explicit model methods description>

Your API calls are described in YAML files. There're can be set default 
values, complex parameter checks, input parameter filters, output filters
and other things.

HTML/AJAX developer can look into these YAML files to understand backend API.

=item B<Safe>

Thanks very comprehensive parameter checks, passed into handler request is
already checked and filtered, you don't need to make additional validation.

=item B<Flexible rules>

Different output filters can be applied to the same data to get different 
data representation. Input data can be obtained automatically from session,
headers, cookies, form and other sources. Results from handlers can set or 
unset headers or cookies. All this is described in YAML and all these 
rules are compiled into native Perl code.

=item B<Routing>

Request routing is very powerful and effective. Your routing rules are 
compiled into native Perl code.

=item B<Highly configurable>

There're many configurable parameters and functions. They have some sensible
defaults that you have to configure only small part of them. It's very easy
to configure them in your own *::AppFrontConfig module. 

=item B<PSGI>

PSGI is very effective protocol for passing incoming requests into 
application. You can use PEF::Front with any PSGI-server. 
I use L<uwsgi|https://uwsgi-docs.readthedocs.io/en/latest/PSGIquickstart.html>. 
It is also very wise to have some reverse-proxy server in front of 
PSGI-server for static content. I use L<Nginx|https://www.nginx.com/>.

=item B<More productive out of the box>

PEF::Front has many components that a really useful for typical web 
applications:

=over

=item Sessions

Session data can be automatically loaded during request validation.

=item Oauth2

There're components to easily make authorization on your site for B<Facebook>, 
B<GitHub>, B<Google>, B<LinkedIn>, B<MSN>, B<PayPal>, B<Vkontakte> 
and B<Yandex> users.

=item Internationalization support

There's a message translation support in templates and handlers and 
automatic language detection based on URL, HTTP headers and Geo IP.

=item Captcha

Captcha check during request validation. Simple captcha component. Custom
captcha image generation is possible.

=back

=back

=head1 Your Application

Typical directory structure of Your application is alike:

    + $project_dir/
      + $app/
        + $Project/
          - AppFrontConfig.pm
          + InFilter/
          + OutFilter/
          + Local/
      + bin/
        - startup.pl
      + model/
      + templates/
      + var/
        + cache/
        + captcha-db/
        + tt_cache/
        + upload/
      + www-static/
        + captchas/
        + images/
        + jss/
        + styles/

You can redefine almost everyting here, except B<InFilter>, B<OutFilter> 
and B<Local> directories.

=cut

