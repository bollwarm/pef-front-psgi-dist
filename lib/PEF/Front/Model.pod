=encoding utf8
 
=head1 PEF::Front model methods description

This is the crucial feature of PEF::Font.

=head1 SYNOPSIS

  /submitUserLogin
  
  # model/UserLogin.yaml

  ---
  params:
    ip:
      value: context.ip
    login:
      min-size: 1
      max-size: 40
    password:
      min-size: 4
      max-size: 40
  model: User::login
  result:
    OK:
      set-cookie:
        auth:
          value: TT response.auth
          expires: TT response.expires
      redirect: /me
    DEFAULT:
      unset-cookie: auth

  /ajaxGetArticles
  
  # model/GetArticles.yaml
  ---
  params:
    ip:
      value: context.ip
    limit:
      regex: ^\d+$        
      max-size: 3
    offset:
      regex: ^\d+$
      max-size: 10
  model: Article::get_articles


 
=head1 DESCRIPTION

For every internal API method there's one YAML-file describing its
parameters, handler method, caching and result processing. 

There're two sources to call these methods from: templates and HTTP requests.

To call this method from template you write it like this:

  [% articles = "get articles".model(offset => articles_offset, limit => 5) %]

To call this method from AJAX you send HTTP request like this:

  GET /ajaxGetArticles?offset=0&limit=5

"Normal" method name is lowercased phrase with spaces. 
Model methods description file name is made up from
method name transformed to CamelCase with '.yaml' extension: 
"get articles" -> "GetArticles.yaml". HTTP request method name is
made up concatenating one of prefixes '/ajax', '/submit', '/get' and CamelCase
form of method name.

=head1 INPUT PARAMETERS

Section "params" describes method input parameters, their sources, 
types and checks. There're two parameter's attribute to set source:
B<value> and B<default>. B<value> means unconditionally set value;
B<default> means that value will be set only if it was not set from
request query or form data parameter. 

Framework automatically decodes input data into internal Perl UTF-8 and
automatically encodes output to UTF-8. This is the only supported encoding.

=head2 Possible sources

=over

=item from query string or form data

This is the default. There's no difference between parameters from query 
string and form data. But when the same parameter is in query and form data
then value from query has precedence. 

There's also special parameter B<json> that has to be encoded JSON value.
When it's present, then parameters are overwritten from this decoded JSON.

Request parsing detects JSON or XML content-types and can parse them.

=item Direct value

B<value> and B<default> can be string or integer.

  ---
  params:
    ip:
      default: 127.0.0.1
    is_active:
      default: 0

=item from context data

B<context> is a hash with some data for handlers. 
It is created after initial routing processing before template or 
API method processing. There're some data:

=over

=item B<ip>

IP address of the client.

=item B<lang>

Short (ISO 639-1) language code. 
There's automatic language detection based on URL, HTTP headers and cookies
and Geo IP. You can turn it off. It's written to 'lang' cookie.

=item B<hostname>

Hostname of current request.

=item B<path>

Current URI path.

=item B<path_info>

Initial URI path.

=item B<method>

Method name.

=item B<scheme>

URL scheme. One of: 'http', 'https'.

=item B<src>

"Source" of the request. One of: 'app', 'ajax', 'submit', 'get'.

=item B<form>, B<headers>, B<cookies>, B<session> and B<request> 

They are also parts of context but they can't be used as values by themselves.
They are used in handlers. 

C<session> is loaded only if it was used for parameter value. 

=item B<template>

For template processing "method" is replaced with "template" 
which is template name.

=item B<time>, B<gmtime>, B<localtime>

These are additional fields for template processing. 
C<time> is current UNIX-time, C<gmtime> - 9-element list with the time in GMT,
C<localtime> - 9-element list with the time for the local time zone. 
See C<perldoc -f> for these functions. 

=back 

Example:

  ---
  params:
    ip:
      value: context.ip
    lang:
      default: context.lang

=item from request parameters

By default parameter "param1" is set from "param1" query/form data,
but it's possible to set it from another request parameter, 
like "another_param". B<form> is meant for this.

  ---
  params:
    ip:
      value: context.ip
    lang:
      default: context.lang
    login:
      value: form.username

=item from headers

  ---
  params:
    ip:
      value: context.ip
    back_url:
      default: headers.referer

=item from cookies

  ---
  params:
    ip:
      value: context.ip
    auth:
      default: cookies.auth

=item from request notes

Routing subroutines can set some notes on request object. Notes are just any
key-value pairs.

  ---
  params:
    ip:
      value: context.ip
    subsection:
      default: notes.subsection


=item from session data

From request parameters or from cookies using B<cfg_session_request_field> 
is possible to automatically load value from session data.

  ---
  params:
    ip:
      value: context.ip
    user_last_name:
      default: session.user_last_name

=item from configuration parameter

You can specify any configuration parameter of framework or your application.

  ---
  params:
    path:
      value: config.avatar_images_path


=back

=head2 Checks

Ther're several types of input data checks. 

=over

=item Perl regular expressions

This is the mostly used method. L<Regexp::Common> with option 'RE_ALL'
is already loaded. When you write an expressions as parameter value 
then it means regexp check. 

  ---
  params:
    positive_integer: ^\d+$
    integer_or_empty: ^\d+$|^$
    any_integer: ^$RE{num}{int}$
    money: ^$RE{num}{decimal}{-places=>"0,2"}$

When you need to add some other attribute then attribute 'regex' is used:

  ---
  params:
    lang:
      default: context.lang
      regex: ^[a-z]{2}$

=item Possible values

Atributes C<can>, C<can_string> and C<can_number> describes set of possible 
values. C<can> and C<can_string> are synonyms.

  ---
  params:
    bool:
      can_number: [0, 1]
      default: 0
    lang:
      can: [en, de]
      default: de

=item Type

Parameter can have type 'array', 'hash' or 'file'. You can specify this with
last symbol of the parameter name '@', '%' or '*' or with attribute 'type'
as 'array', 'hash' or 'file'. To submit array you can use PHP-syntax:

  <!-- HTML -->
  <select name="select[]" multiple="multiple">
  
  # YAML
  ---
  params:
    select@:

Another way to submit array or hash is to use C<json> form data field or 
to post JSON or XML content.

Array of files has type 'array'.

=item Maximum or minimum size

This checks are working according to parameter type: 

=over

=item string length for scalars

=item array size for arrays

=item file size for files

=back

Min/max values are included in allowed range.

  ---
  params:
    limit40str:
      max-size: 40
    limit4_40str:
      min-size: 4
      max-size: 40

=item Maximum or minimum value

Numerical checks. Min/max values are included in allowed range.

  ---
  params:
    speed:
      max: 140
      min: 20

=item captcha

Captcha validation process usually removes information from captcha database
and this check can be done only once. Validation process makes all needed 
checks. 

This works following way. One parameter contains entered captcha 
code and another parameter contains hashed data of the right captcha code.
Attribute C<captcha> specifies parameter with hashed data of the right captcha 
code. Validator checks whether the code is right. If entered captcha is
equal to 'B<nocheck>' then it means to validator 'no need to check captcha' and 
no check is done. If captcha is required then handler must check that entered
captcha code is not equal to 'B<nocheck>'.

=item Optional flag

Attribute C<optional> specifies whether parameter is optional.  
Special value 'empty' means parameter is optional even when passed but 
contains only empty string.

=item Custom filter

Filter can be a Perl subroutine, regular expression substitution or array
of regular expression substitutions.

  ---
  params:
    auth:
      default: cookies.auth
      max-size: 40
      filter: Auth::required
    comment:
      max-size: 1000
      filter: [ s/</&lt;/g, s/>/&gt;/g ]

Recognized substitution operators are: C<s>, C<tr> and C<y>.

C<Auth::required> actually means subroutine C<required($value, $context)>
from your module C<${YourApplicationNamespace}::InFilter::Auth>.

I.e.:

    + $project_dir/
      + $app/
        + $Project/
          - AppFrontConfig.pm
          + InFilter/
            - Auth.pm

Your subroutine recieves 2 arguments: value of the parameter and request 
context.

  package MyApp::InFilter::Auth;
  use DBIx::Struct;
  use MyApp::Common;

  sub required {
    my ($value, $context) = @_;
    my $author = get_author_from_auth($value);
    die {
      result => "NEED_LOGIN",
      answer => 'You have to login for this operation'
    } unless $author;
    $value;
  }

When filter dies for optional parameter then this parameter is deleted from
request as if it was not provided. For required fields this means failed 
validation. 

=item Kind of inheritance

There's special YAML-file B<-base-.yaml> in your B<cfg_model_dir> where you
can write all common requests parameters and just use these descriptions
in your model methods description files.

  -base-.yaml
  ---
  params:
    ip:
      value: context.ip
    auth:
      default: cookies.auth
      max-size: 40
    auth_required:
      base: auth
      filter: Auth::required
    limit:
      regex: ^\d+$        
      max-size: 3
    offset:
      regex: ^\d+$
      max-size: 10
    positive_integer: ^\d+$
    integer_or_empty: ^\d+$|^$
    any_integer: ^$RE{num}{int}$
    bool:
      can_number: [0, 1]
      default: 0
    money: ^$RE{num}{decimal}{-places=>"0,2"}$

Attribute C<base> allows to specify "inheritance" of the properties for
corresponding parameter from B<-base-.yaml>. 
It works even inside B<-base-.yaml>. When you write an expressions 
with leading C<$> as parameter value then it means "inheritance".

  ---
  params:
    ip: $ip
    auth: 
      base: $auth
      optional: true
    id_article: $positive_integer
    id_comment_parent:
      base: $integer_or_empty
      filter: Empty::to_undef
    author:
      base: $limit40str
      min-size: 1
      filter: Default::auth_to_author

=back

=head2 Extra parameters

Special key C<extra_params> controls what to do when there're more
parameters as required: B<ignore> - all extra parameters will be 
silently deleted; B<pass> - all extra parameters will be passed 
without validation; B<disallow> - validation fails when extra parameters
passed.

  ---
  params:
    ip: $ip
  extra_params: pass

=head2 Output result

Handlers are supposed to return hash like these.

  {
    result => "OK",
  } 

or

  {
    result => "SOMEERRCODE",
    answer => 'Some $1 Error $2 Message $3',
    answer_args => [$some, $error, $params],
  }

C<result> is required in every answer, other keys are optional.

Following keys have some meaning:

=over

=item B<result>

Is symbolic result state. 

=over

=item "OK" means everything is good

=item "INTERR" means some internal application error

=item "OAUTHERR" means Oauth protocol error

=item "BADPARAM" means validation error

=back

Application can use its own codes.

=item B<answer>

Message from application.

=item B<answer_args>

Array of arguments to the message.

=item B<answer_headers>

Array of key-value pairs that will be set as output HTTP headers and their 
values. Key-value pairs can be list ($header => $value), 
array [$header => $value] or hash {$header => $value}.

=item B<answer_cookies>

Array of key-value pairs that will be set as output HTTP cookies and their 
values. Key-value pairs can be list ($cookie => $value), 
array [$cookie => $value] or hash {$cookie => $value}.

=item B<answer_no_nls>

If present and true then C<answer> will be send as is, without localization 
attempt.

=item B<answer_status>

Sets HTTP status code. If C<answer_status> is between 300 and 400 then 
C<Location> headers specifys new location for redirect.

=item B<answer_content_type>

Sets Content-Type header.

=back

When method is called like C</ajax> then it means JSON format answer. 
When you need another output format, use C</get> or C</submit> type calls.

=head2 Response caching

Some methods can return constant or rarely changing data, 
it makes perfect sense to cache them.
Key C<cache> manages caching for responses. It has to attributes:
C<key> - one value or array defining caching key; 
C<expires> - how long data can be retained in cache. 
This value is parsed by L<Time::Duration::Parse>.

  ---
  params:
    id_user: $positive_integer
  cache:
    key: [method, id_user]
    expires: 1m

=head2 Result processing

Response key C<result> defines C<result>'s section to execute some actions. 
When no section is found then it looks for C<DEFAULT> section. 
Following actions are supported:

=over

=item B<redirect> 

Temporary browser redirect (302) for C</get> or C</submit> request types.

=item B<set-cookie> - set cookie. 

Possible attributes: C<value>, C<expires>, C<domain>, C<path>, C<secure>, 
C<max-age>, C<httponly>.

C<secure> attribute can be calculated automatically from request's scheme 
when setting or unsetting cookie if not explicitly set in attributes.

=item B<unset-cookie>

Unsets cookie. It can be one cookie name, list of cookies or hash of cookies 
with their attributes as for C<set-cookie>.

=item B<filter>

Specifies output filter.

=item B<answer>

Sets answer content.

=item B<set-header>

Sets response header. This action ensures that there's only one header 
with given name in response.

=item B<add-header>

Adds response header. This action allows to have multiple headers 
with the same name.

=back

  ---
  params:
    back_url:
      default: headers.referer
  result:
    OK:
      set-cookie:
        auth:
          value: TT response.auth
          expires: TT response.expires
      redirect: /me
    DEFAULT:
      unset-cookie: auth
      redirect: TT request.back_url

Prefix C<TT> means "process this expression with Template-Toolkit language".
This prefix can be used for any attribute value in C<result> section. 

Stash for this processing contains following data fields: 
C<response>, C<form>, C<cookies>, C<context>, C<request>, C<result>.

There're two additional helper functions: C<uri_unescape($uri)> 
and C<session($key)>. $key is optional. 

=head2 Output filter

It's possible to specify filtering function for sending content. 
Attribute C<filter> for given C<result code> in C<result> section 
specifies function that accepts two parameters: ($response, $context).

  ---
  result:
    OK:
      filter: Export::toXML


C<Export::toXML> actually means subroutine C<toXML($response, $context)>
from your module C<${YourApplicationNamespace}::OutFilter::Export>.

$response must be modified "in-place", return value of subroutine is ignored.

Intended application is to transform response to external form, 
like XML, CSV, XLS and so on.

=head2 Model handler

Key C<model> sets calling model handler. 
Model can be "local" or "remote". "Local" means that handler is right 
inside loaded application. "Remote" can mean everything, like 
"call database method". "Remote" model is handled by 
C<cfg_model_rpc($model_handler)>. "Local" is located in some module inside
C<${YourApplicationNamespace}::Local::*>.

  ---
  params:
    ip: $ip
    login:
      base: limit40str
      min-size: 1
    password: $limit4_40str
  model: Author::login

#  $project_dir/$app/$Project/Local/Author.pm

  package MyApp::Local::Author;
  sub login {
    my ($req, $context) = @_;
    my $author = one_row(author => {hash_ref_slice $req, qw(login password)})
      or return {result => "PASS"};
    my $auth = PEF::Front::Session::_secure_value;
    new_row( 'author_auth',
      id_author => $author->id_author,
      auth      => $auth,
      expires   => [\"now() + ?::interval", $expires]
    );
    return { 
      result  => "OK",
      expires => $expires,
      auth    => $auth
    };
  }

Model handler that matches /^\w+::/ is "local" otherwise is "remote".

=head1 AUTHOR
 
This module was written and is maintained by Anton Petrusevich.

=head1 Copyright and License
 
Copyright (c) 2016 Anton Petrusevich. Some Rights Reserved.
 
This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
